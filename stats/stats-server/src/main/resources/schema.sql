-- stats/stats-server/src/main/resources/schema.sql

-- Таблица для хранения информации о просмотрах
CREATE TABLE IF NOT EXISTS hits (
                                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                                    app VARCHAR(255) NOT NULL CHECK (LENGTH(TRIM(app)) >= 1),
    uri VARCHAR(1024) NOT NULL CHECK (LENGTH(TRIM(uri)) >= 1),
    ip VARCHAR(45) NOT NULL CHECK (ip ~ '^([0-9]{1,3}\.){3}[0-9]{1,3}$|^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$'),
    timestamp TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,

    -- Проверка даты
    CONSTRAINT chk_timestamp_range CHECK (timestamp >= '2020-01-01' AND timestamp <= CURRENT_TIMESTAMP + INTERVAL '1 year'),

    -- Для предотвращения дублирования (опционально)
    CONSTRAINT uq_hit_unique UNIQUE (app, uri, ip, timestamp)
    );

-- Основные индексы
CREATE INDEX IF NOT EXISTS idx_hits_timestamp ON hits(timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_hits_uri ON hits(uri);
CREATE INDEX IF NOT EXISTS idx_hits_app ON hits(app);
CREATE INDEX IF NOT EXISTS idx_hits_ip ON hits(ip);

-- Составные индексы для частых запросов
CREATE INDEX IF NOT EXISTS idx_hits_app_uri ON hits(app, uri);
CREATE INDEX IF NOT EXISTS idx_hits_timestamp_uri ON hits(timestamp, uri);
CREATE INDEX IF NOT EXISTS idx_hits_app_timestamp ON hits(app, timestamp);
CREATE INDEX IF NOT EXISTS idx_hits_uri_timestamp ON hits(uri, timestamp DESC);

-- Частичный индекс для актуальных данных (последние 30 дней)
CREATE INDEX IF NOT EXISTS idx_hits_recent ON hits(timestamp DESC)
    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '30 days';

-- Индекс для уникальных подсчетов
CREATE INDEX IF NOT EXISTS idx_hits_app_uri_ip ON hits(app, uri, ip);

-- Таблица для агрегированной статистики (опционально, для повышения производительности)
CREATE TABLE IF NOT EXISTS aggregated_stats (
                                                id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                                                app VARCHAR(255) NOT NULL,
    uri VARCHAR(1024) NOT NULL,
    period_date DATE NOT NULL,
    total_hits BIGINT NOT NULL DEFAULT 0,
    unique_hits BIGINT NOT NULL DEFAULT 0,
    last_updated TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT uq_aggregated_stats UNIQUE (app, uri, period_date)
    );

-- Индексы для агрегированной статистики
CREATE INDEX IF NOT EXISTS idx_aggregated_app_uri ON aggregated_stats(app, uri);
CREATE INDEX IF NOT EXISTS idx_aggregated_period_date ON aggregated_stats(period_date);
CREATE INDEX IF NOT EXISTS idx_aggregated_app_period ON aggregated_stats(app, period_date);

-- Вью для получения статистики (упрощает запросы)
CREATE OR REPLACE VIEW view_stats AS
SELECT
    app,
    uri,
    COUNT(*) as hits,
    COUNT(DISTINCT ip) as unique_hits
FROM hits
GROUP BY app, uri;

-- Функция для получения статистики за период
CREATE OR REPLACE FUNCTION get_stats(
    start_time TIMESTAMP,
    end_time TIMESTAMP,
    uris_filter TEXT[] DEFAULT NULL,
    unique_only BOOLEAN DEFAULT FALSE
) RETURNS TABLE (
    app VARCHAR,
    uri VARCHAR,
    hits BIGINT
) AS $$
BEGIN
    IF unique_only THEN
        RETURN QUERY
SELECT
    h.app,
    h.uri,
    COUNT(DISTINCT h.ip) as hits
FROM hits h
WHERE h.timestamp BETWEEN start_time AND end_time
  AND (uris_filter IS NULL OR h.uri = ANY(uris_filter))
GROUP BY h.app, h.uri
ORDER BY hits DESC;
ELSE
        RETURN QUERY
SELECT
    h.app,
    h.uri,
    COUNT(*) as hits
FROM hits h
WHERE h.timestamp BETWEEN start_time AND end_time
  AND (uris_filter IS NULL OR h.uri = ANY(uris_filter))
GROUP BY h.app, h.uri
ORDER BY hits DESC;
END IF;
END;
$$ LANGUAGE plpgsql;

-- Триггер для автоматического агрегирования статистики (опционально)
CREATE OR REPLACE FUNCTION update_aggregated_stats()
RETURNS TRIGGER AS $$
BEGIN
INSERT INTO aggregated_stats (app, uri, period_date, total_hits, unique_hits)
VALUES (
           NEW.app,
           NEW.uri,
           DATE(NEW.timestamp),
           1,
           1
       )
    ON CONFLICT (app, uri, period_date) DO UPDATE
                                               SET
                                                   total_hits = aggregated_stats.total_hits + 1,
                                               unique_hits = aggregated_stats.unique_hits +
                                               CASE WHEN NEW.ip NOT IN (
                                               SELECT ip FROM hits
                                               WHERE app = NEW.app
                                               AND uri = NEW.uri
                                               AND DATE(timestamp) = DATE(NEW.timestamp)
                                               AND ip != NEW.ip
                                               ) THEN 1 ELSE 0 END,
        last_updated = CURRENT_TIMESTAMP;

RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Создание триггера (опционально, можно включать для больших нагрузок)
-- CREATE TRIGGER trigger_update_aggregated_stats
-- AFTER INSERT ON hits
-- FOR EACH ROW
-- EXECUTE FUNCTION update_aggregated_stats();

-- Функция для очистки старых данных
CREATE OR REPLACE FUNCTION cleanup_old_hits(retention_days INTEGER DEFAULT 365)
RETURNS INTEGER AS $$
DECLARE
deleted_count INTEGER;
BEGIN
DELETE FROM hits
WHERE timestamp < CURRENT_TIMESTAMP - (retention_days || ' days')::INTERVAL;

GET DIAGNOSTICS deleted_count = ROW_COUNT;
RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;